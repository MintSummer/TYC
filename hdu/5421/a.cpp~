#include<iostream>
#include<algorithm>
#include<ctime>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<string>
#include<vector>
#include<map>
#include<set>
#include<queue>
#include<stack>
#include<list>
#include<numeric>
using namespace std;
#define LL long long
#define ULL unsigned long long
#define INF 0x3f3f3f3f3f3f3f3f
#define mm(a,b) memset(a,b,sizeof(a))
#define PP puts("*********************");
template<class T> T f_abs(T a){ return a > 0 ? a : -a; }
template<class T> T gcd(T a, T b){ return b ? gcd(b, a%b) : a; }
template<class T> T lcm(T a,T b){return a/gcd(a,b)*b;}
// 0x3f3f3f3f3f3f3f3f
 
const int MAXN = 200005, SIZE = 26;
struct Palindromic_Tree {
	int next[MAXN][SIZE];//next指针
	int fail[MAXN];//fail指针
	int cnt[MAXN];//表示节点i表示的本质不同的串的个数(建树时求出的不是完全的,最后Count()函数跑一遍以后才是正确的)
	int num[MAXN];//表示以节点i表示的最长回文串的最右端点为回文串结尾的回文串个数
	int len[MAXN];//len[i]表示节点i表示的回文串的长度
	int S[MAXN];//存放添加的字符 S[MAXN << 1]
//	int last;//指向上一个字符所在的节点,方便下一次add
	int n;//字符数组指针 //lbd, rbd
	int p;//节点指针
	int lbd,rbd;
	int last[2];//0表示在字符串的首部加上一个字符，1表示在尾部加上一个字符
	int NewNode(int l) {//新建节点
		for(int i = 0; i < SIZE; ++i)
			next[p][i] = 0;
		cnt[p] = num[p] = 0;
		len[p] = l;
		return p++;
	}
	void Init(int x) {//初始化
	/*	p = n = 0;
		NewNode(0); NewNode(-1);
		last = 0;
		S[n] = -1;//开头放一个字符集中没有的字符,减少特判*/
		p=0;
		NewNode(0); NewNode(-1);
		last[0] = last[1] = 0;
		memset(S, -1, sizeof(S));
		lbd = x; rbd = x - 1;//x是字符串的最大长度
		fail[0] = 1;
	}
	int GetFail(int x, int d) {//和KMP一样,失配后找一个尽量最长的
//		while(S[n - len[x] - 1] != S[n]) x = fail[x];
		if(d == 0) while(S[lbd + len[x] + 1] != S[lbd]) 
		    x = fail[x];
		else while(S[rbd - len[x] - 1] != S[rbd]) x = fail[x];
		return x;
	}
	int Add(int c, int d) {
		//S[++n] = c;
		if(d == 0) S[--lbd] = c; else S[++rbd] = c;
		int cur = GetFail(last[d], d);
	//	int cur = GetFail(last);//通过上一个回文串找这个回文串的匹配位置
		if(!next[cur][c]) {//如果这个回文串没有出现过,说明出现了一个新的本质不同的回文串
			int now = NewNode(len[cur] + 2);//新建节点
			fail[now] = next[GetFail(fail[cur], d)][c];//和AC自动机一样建立fail指针,以便失配后跳转
			next[cur][c] = now;
			num[now] = num[fail[now]] + 1;
		}
	//	last = next[cur][c];
	//	cnt[last]++;
        last[d]=next[cur][c];
		if(len[last[d]] == rbd - lbd + 1) last[d ^ 1] = last[d];
		return num[last[d]];
	}
	void Count() {
		for(int i = p - 1; i >= 0; --i)
			cnt[fail[i]] += cnt[i];
		//父亲累加儿子的cnt,因为如果fail[v]=u,则u一定是v的子回文串！
	}
}tree;
int main(){
    freopen("a.in","r",stdin); 
    int n,op;
    char ch[10];
    while(~scanf("%d",&n)){
        tree.Init(n);
        LL ans=0;
        for(int i=1;i<=n;i++){
            scanf("%d",&op);
            if(op==1){
                scanf("%s",ch);
                ans+=tree.Add(ch[0]-'a',0);
            }
            else if(op==2){
                scanf("%s",ch);
                ans+=tree.Add(ch[0]-'a',1);
            }
            else if(op==3){
                printf("%d\n",tree.p-2);
            }
            else{
                printf("%lld\n",ans);
            }
        }
    }
    return 0;
}
