#include<bits/stdc++.h>
#define lca long long
#define N 1005
#define inf 0x7f7f7f7f
using namespace std;
struct node
{
	int u,v;
	lca w;
}edge[N*N];
int pre[N],id[N],vis[N],n,m,pos;
lca in[N];
lca Directed_MST(int root,int V,int E)
{
	lca ret=0;
	while(true)
	{
		for(int i=0;i<V;i++)in[i]=inf;
		for(int i=0;i<E;i++)
		{
			int u=edge[i].u;
			int v=edge[i].v;
			if(edge[i].w<in[v]&&u!=v)
			{
				pre[v]=u;
				in[v]=edge[i].w;
				if(u==root)pos=i;
			}
		}
		for(int i=0;i<V;i++)
		{
			if(i==root)continue;
			if(in[i]==inf)return -1;
		}
		int cnt=0;
		memset(id,-1,sizeof(id));
		memset(vis,-1,sizeof(vis));
		in[root]=0;
		for(int i=0;i<V;i++)
		{
			ret+=in[i];
			int v=i;
			while(vis[v]!=i&&id[v]==-1&&v!=root)
				vis[v]=i,v=pre[v];
			if(v!=root&&id[v]==-1)
			{
				for(int u=pre[v];u!=v;u=pre[u])id[u]=cnt;
				id[v]=cnt++;
			}
		}
		if(cnt==0)break;
		for(int i=0;i<V;i++)if(id[i]==-1)id[i]=cnt++;
		for(int i=0;i<E;i++)
		{
			int u=edge[i].u;
			int v=edge[i].v;
			edge[i].u=id[u];
			edge[u].v=id[v];
			if(id[u]!=id[v])edge[i].w-=in[v]; 
		}
		V=cnt;root=id[root];
	}
	return ret;
}
int main()
{
	while(~scanf("%d%d",&n,&m))
	{
		lca sum=0;
		for(int i=0;i<m;i++)
		{
			scanf("%d%d%lld",&edge[i].u,&edge[i].v,&edge[i].w);
			edge[i].u++,edge[i].v++;
			sum+=edge[i].w;
		}
		sum++;
		for(int i=m;i<m+n;i++)
		{
			edge[i].u=0;
			edge[i].v=i-m+1;
			edge[i].w=sum;
		}
		lca ans=Directed_MST(0,n+1,m+n);
		if(ans==-1||ans-sum>=sum)puts("impossible");
		else printf("%lld %d\n",ans-sum,pos-m);
		puts("");
	}
	return 0;
}
