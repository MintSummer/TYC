#include<bits/stdc++.h>
using namespace std;
const int MAXN=61*10;
const int inf=0x3f3f3f3f;
int n,m,cnt=1,s=0,t=1005,ans;
int tim[12][65],f[MAXN],pre[MAXN],Head[MAXN],q[MAXN];
bool vis[MAXN];
/*
把每个工人拆成N个点。记为A[i,j]表示第i个工人修倒数第j辆车
i表示工人,j表示工人i修倒数第j个,k表示工人i倒数第j个修的是哪辆车
考虑第i个工人，他修第j辆车只对后面要修的车有影响，而前面修过的车已经对当前没有影响了,而这个影响就是后面每个将要修理的车都多等待了time的时间
*/

struct edge
{
    int from,to,next,w,c;
}E[100010];

inline void insert(int u,int v,int w,int c)
{
    E[cnt]=(edge){u,v,Head[u],w,c};
    Head[u]=cnt++;
    E[cnt]=(edge){v,u,Head[v],0,-c};
    Head[v]=cnt++;
}

bool spfa()
{
    for(int i=s;i<=t;i++) f[i]=inf;
    int head=0,top=1;
    f[s]=0,vis[s]=1;
    q[1]=s;
    while(head!=top)
    {
	int u=q[++head];
	vis[u]=0;
	if(head==t) head=0;
	for(int i=Head[u];i;i=E[i].next)
    	    if(E[i].w>0&&f[E[i].to]>f[u]+E[i].c)
	    {
		f[E[i].to]=f[u]+E[i].c;
		pre[E[i].to]=i;
		if(!vis[E[i].to]) 
		{
		    vis[E[i].to]=1,q[++top]=E[i].to;
		    if(top==t) top=0;
		}
	    }
    }
    if(f[t]==inf) return false;
    else return true;
}

void EK()
{  
    int mn=inf;
    for(int i=pre[t];i;i=pre[E[i].from])
	 mn=min(mn,E[i].w);
    for(int i=pre[t];i;i=pre[E[i].from])
	E[i].w-=mn,E[i^1].w+=mn,ans+=mn*E[i].c;
}

int main()
{
    scanf("%d%d",&m,&n);
    for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++) scanf("%d",&tim[i][j]);

    for(int i=1;i<=n*m;i++)
	insert(s,i,1,0);
    for(int i=n*m+1;i<=n*m+n;i++)
	insert(i,t,1,0);
    
    for(int i=1;i<=m;i++)
	for(int j=1;j<=n;j++)
	    for(int k=1;k<=n;k++)
		insert((i-1)*n+j,m*n+k,1,tim[k][i]*j);
    

    while(spfa()) EK(); 
    printf("%.2lf",(double)ans/n);
    return 0;
}
